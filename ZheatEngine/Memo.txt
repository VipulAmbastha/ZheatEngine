搜字符串和array of bytes这些类似的，可以用到那个算法，避免完全回退那个

完全写入硬盘太慢了，完全存内存太大了。
所以可以配置一个buffer。

CE的做法是配两个buffer，一个处理，同时另一个从硬盘读？
好像也不是啊。。
又看见是普通的next scan也是直接从硬盘读。
不过不是像我这样一个一个读，而是一个chunk一个chunk读。所以比我快么？
有道理，硬盘读的大小有个最佳大小好像，也是4096？

UI里面更新now value，只更新能看到的，一般只有十几个，所以直接每个都用一次read process memory

进一步的思想是，用bitmap代表offsest，用来减小存指针的数据大小。
用region用来减少read process memory的次数。
一个问题是如果指针很稀疏怎么办。还没想好

CE有一个做法，不是从远程进程的virtual query得到两个地址在一起，而是直接分析两个地址是否在一个页里。
如果在，就一次read process memory处理掉
有道理啊！
TScanner.nextnextscanmem 这个里面记录了作者的profile
他决定除了一个4096page 只有一个的情况，其他都是读覆盖了整个page内需要地址的所有部分
我是不是可以再试试我之前的想法。。。读整个region里的覆盖面？说不定更快哦。但是与此同时指针稀疏问题也更严重了。
不像4096，不怎么亏（根据他的测试）

还有一个UI的trick是，搜到什么就先显示什么，不用搜完。

还有个UNDO功能没有实现。

注意 first scan的virtual query之后，可能内存格局变了。所以要处理一下read process memory 失败的情况。
还有个思路是把相关内存操作的函数hook掉
next scan也可能内存格局变了，也要注意。
write的时候也是。
还有有可能write的地方内存格局没变，就是单纯的不让写。可以先把属性改了，写入，再改回来

除了bitmap，有没有可能再用别的 非通用压缩方式 。

可以结合的，bitmap在内存里也用上，在硬盘里也用上？

不知道为什么大家都喜欢主动从dll里读某些函数，不直接include windows.h 直接用？
我要不要也这样
而且还有些用obfuscated名称，临时解读出来再读取dll。。。

CE还用了多线程，但是暂时有点看不懂。。。

procedure TScanController.NextNextScan;
这个里面提到了 Adress.TMP的格式是 address， offset0, offset1 .... address, offset0 offset1 ...
很像嘛。。和region bitmap的设计差不多

如果用 缓冲区的话
记得好像那个什么，一个消费者一个生产者的那个无锁缓冲区

还有那个，多线程的话。
类似拿什么memcpy的多线程思路。
假如4个核， 
0，4，8，12   
1，5，9，13  
2，6，10，14  
3，7，11，15
这样，似乎对cpu cache最友好？
或者分四段，似乎也可以

似乎明白了
CE的设计是ScanController把文件里的工作切分一下，分给多线程的Scanner

procedure TScanController.nextScan;
这个里面也是，分成了 region scan和result scan

看来速度差异关键就在多线程、缓存、read process memory一次读4096内覆盖范围、读文件一次读xxx？……

firstScan按region分成了jobs
unknown initial它是把所有内存都读出来存到一个巨大的buffer里，再处理
不，源码里有个 ifdef low memory scan，那就存文件
否则就都弄内存里

各个线程开始折腾，都存到自己的后缀的results-xxx.TMP
然后controller再合并
（具体是文件合并还是内存合并 似乎还有说法）
合并应该可以有优化的，CE里面也有个todo，不做真正的文件拷贝或者内存拷贝，而是做一下类似软连接，指针的工作

CE还有个 wait till done
wait till really done
。。。
这就是UI的那个trick把

可以加一个显示进行了百分之多少的东西
不太费劲把


想了想，CE就是第一次的时候把所有memory都读到一起再处理
拿2g的ow试了试，很快。所以说感觉完全可以用region读覆盖区域，而不是4096读覆盖区域。
再想想到底哪些要存硬盘。bitmap压缩否？其他压缩否？



不过有个问题啊，这样整完需要排序的
难道每次要结果时都主动按地址排序一次？
不过地址是固定位数的，可以用桶排等线性排序

还是测测，感受一下卡不卡最好

CE里面好像没管万一read process memory失败了怎么办

我感觉还是要管管的吧。
如果一个一个读，那好说。现在的实现已经处理好了。
如果4096覆盖读，或者region覆盖读。那最好整块失败了要单独测试一下，很有可能某部分内存格局变了。但是其他还好
可以看看LastError，不是有个299是一部分成功么

或者就干脆不看成功与否？ 会导致什么情况呢

感觉如果用bitmap的话，bitmap也别写磁盘了，就一直留内存就行了
再算上alignment过滤掉的，简直很小很小了

STL的bitset需要编译期常量的N
可以用std::vector<bool>不过不一定优化成这样
也可以boost::dynamic_bitset
也可以自己写一个，反正不需要太多功能

其实也可以不一个region配一个bitset，而是4096配一个bitset。
不过这样要考虑跨页的
不过CE也应该考虑跨页，它怎么没搞？还是我没注意么

看了看我的电脑上vector<bool>的实现的确是用了bit压缩
但是这个能保证么？
应该可以吧，这个应该是很通用的处理

没关系，封装一下，先凑合用着，不行再把实现改成自己的

如果按region的话，重构成顺序结构，还是比较容易合并的
前面的region的结果放前面即可
多线程可以跑

记得CE还处理了一个地方，virtual query的时候，可能前后两次得到的是相邻的
直接合并起来

感觉memory也别弄什么一部分buffer，一部分硬盘了。
直接全存到硬盘，处理时候把整个region的memory都一起都进来
这样和first scan一样

不对，其实还是可以搞，如果加起来都很小的话，直接全存内存也不是不可以


ring buffer还是cycle buffer，忘了叫啥了
正好这里处理region的时候，读数据，然后同时让它自己去读硬盘的
或者还是弄两个buffer，一个处理的时候另一个读硬盘？

还是不统一，让每个region可以多线程，但是这样容易造成内存同时load进来。
如果改成每个region都不一次读进来，还是慢慢读，不过可以读个chunk，这样可以多线程了

可以不非要自己弄个buffer。
这样，每个region都自己申请自己的buffer。如果加起来超了一个限度，就写磁盘。
这样舒服多了。。不用费劲儿去管理buffer了
比如first scan， 每个region都试图直接存进内存，但是如果超限了，就写磁盘。
下次根据情况从内存或者从磁盘读

可是这样的话，有点浪费啊。 能否预判一下，然后提前load进来，把不用的放出去
我感觉可以，如果保证我顺序访问，那很容易预判的。


而且region的memory存的时候，直接存覆盖部分还是存真正value


注意一下，真正受不了的是大量处理的时候很慢。
大量处理的时候如果快了，然后少量处理更慢了，其实我无所谓。因为少量处理再慢也没多慢


把单线程，整个region的处理了。发现还是很慢
看来硬盘IO是一个瓶颈。但是内存IO和计算也很耗时间。

还有一个，UI里面的tree widget的item的添加。每次都是重新new，重用一下好了


目前这个，按region处理，buffer也是各region自己管，只看总大小超没，超了就自己写到磁盘，到时候自己读出来。
完美多线程。。

只要取results的时候，顺序从region取，就可以保证结果是顺序的。

把这个搞好，弄线程池或者jobs 消费者？好了


还有，现在是整个region存取，处理。region全空再去掉
最好再细化一点。稍微有点浪费
或者不需要？极端情况没那么多？

本来的话，如果多线程了，会导致临时用的内存峰值比较高。
但是如果只有4核比如说，开4个worker，再加上一个region一般也没多大，峰值也该不算太夸张吧。

想起来可以用PPL，很舒服，但是PPL的并发就不止4个worker了吧。。峰值会比较高。
如果PPL可以4worker 并发。
有道理，用PPL弄4 worker，应该可以吧
..似乎还真没有现成的。
不过qt好像也有类似的东西，看看

也可以不用执着于几个worker，我的目的是峰值不要太高。那我再parallel for each里限制一下，
超过限度了就等着，把峰值抹平，就行了吧

有有有。。发现Qt有 从thread pool里拿线程的run。
那。。用哪种
感觉那个限制峰值的更好



实现以后，现在的已经很快了,再加一个settings吧
还有其他UI的设计

还有其他数据类型的查找

还有，重构！！！！


还有，命名方式，之前瞎写没改，现在规整一下


ui的输入，注意一下start 和stop，core里没检测，所以UI里处理一下。


发现了，最卡的地方是 没过滤掉MEM_MAPPED
还有，CE一般只搜WRITEABLE

这两个条件一样了，就秒开了
